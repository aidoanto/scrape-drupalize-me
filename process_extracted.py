"""
Process extracted Drupalize.me content into Obsidian vault.

This script takes the JSON files generated by the browser extraction scripts
and converts them into a proper Obsidian vault structure with:
- Markdown files for each tutorial
- Downloaded images and videos
- Proper cross-linking between tutorials

Usage:
    uv run python process_extracted.py --content-dir ./extracted --vault-dir ./vault
"""

import asyncio
import json
import re
from pathlib import Path
from typing import Optional
from urllib.parse import urlparse, urljoin

import aiofiles
import aiohttp
import click
from bs4 import BeautifulSoup
from markdownify import markdownify as md
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn

console = Console()


def slugify(text: str) -> str:
    """Convert text to a valid filename slug."""
    text = text.lower()
    text = re.sub(r'[^\w\s-]', '', text)
    text = re.sub(r'[-\s]+', '-', text)
    return text.strip('-')


def html_to_markdown(html: str, base_url: str = "https://drupalize.me") -> str:
    """Convert HTML to Obsidian-compatible markdown."""
    if not html:
        return ""
    
    soup = BeautifulSoup(html, 'html.parser')
    
    # Remove unwanted elements
    for element in soup.find_all(['script', 'style', 'nav', 'footer', 'aside']):
        element.decompose()
    
    # Convert to markdown
    markdown = md(
        str(soup),
        heading_style="ATX",
        bullets="-",
        code_language_callback=lambda el: el.get('class', [''])[0].replace('language-', '') if el.get('class') else ''
    )
    
    # Clean up excessive newlines
    markdown = re.sub(r'\n{3,}', '\n\n', markdown)
    
    return markdown.strip()


def create_frontmatter(content: dict) -> str:
    """Create YAML frontmatter for Obsidian."""
    fm = ["---"]
    fm.append(f"title: \"{content.get('title', 'Untitled').replace('\"', '\\'+'\"')}\"")
    fm.append(f"url: \"{content.get('url', '')}\"")
    
    if content.get('guide'):
        fm.append(f"guide: \"[[{content['guide']}]]\"")
    
    if content.get('topics'):
        topics = [f"  - \"{t}\"" for t in content['topics']]
        fm.append("topics:")
        fm.extend(topics)
    
    if content.get('drupalVersions'):
        versions = [f"  - \"{v}\"" for v in content['drupalVersions']]
        fm.append("drupal_versions:")
        fm.extend(versions)
    
    fm.append("---")
    return '\n'.join(fm)


async def download_file(session: aiohttp.ClientSession, url: str, dest_path: Path) -> bool:
    """Download a file from URL to destination path."""
    try:
        async with session.get(url, timeout=aiohttp.ClientTimeout(total=300)) as response:
            if response.status == 200:
                dest_path.parent.mkdir(parents=True, exist_ok=True)
                async with aiofiles.open(dest_path, 'wb') as f:
                    async for chunk in response.content.iter_chunked(8192):
                        await f.write(chunk)
                return True
    except Exception as e:
        console.print(f"[yellow]Warning: Could not download {url}: {e}[/yellow]")
    return False


async def download_vimeo_video(session: aiohttp.ClientSession, vimeo_url: str, dest_path: Path) -> bool:
    """
    Download a Vimeo video. Note: This requires the direct video URL,
    which may need authentication or special handling.
    """
    # Vimeo videos typically require their API or special handling
    # For now, we'll save the URL as a placeholder
    console.print(f"[yellow]Note: Vimeo video at {vimeo_url} - manual download may be required[/yellow]")
    
    # Save URL to a text file for manual download
    url_file = dest_path.with_suffix('.url')
    async with aiofiles.open(url_file, 'w') as f:
        await f.write(f"[InternetShortcut]\nURL={vimeo_url}\n")
    return False


class VaultBuilder:
    """Builds an Obsidian vault from extracted content."""
    
    def __init__(self, vault_dir: Path, content_dir: Path):
        self.vault_dir = vault_dir
        self.content_dir = content_dir
        self.guides_dir = vault_dir / "Guides"
        self.tutorials_dir = vault_dir / "Tutorials"
        self.assets_dir = vault_dir / "assets"
        self.images_dir = self.assets_dir / "images"
        self.videos_dir = self.assets_dir / "videos"
        
    def setup_directories(self):
        """Create vault directory structure."""
        for dir_path in [self.guides_dir, self.tutorials_dir, self.images_dir, self.videos_dir]:
            dir_path.mkdir(parents=True, exist_ok=True)
    
    async def process_all(self):
        """Process all extracted content."""
        self.setup_directories()
        
        # Load URLs data
        urls_file = self.content_dir / "drupalize_urls.json"
        if urls_file.exists():
            with open(urls_file) as f:
                urls_data = json.load(f)
            await self.create_guide_index(urls_data)
        
        # Load content batches
        content_files = sorted(self.content_dir.glob("drupalize_content_batch_*.json"))
        
        if not content_files:
            console.print("[yellow]No content batch files found. Run extract_content.js first.[/yellow]")
            return
        
        all_tutorials = []
        for content_file in content_files:
            with open(content_file) as f:
                batch_data = json.load(f)
                all_tutorials.extend(batch_data.get('tutorials', []))
        
        console.print(f"[green]Found {len(all_tutorials)} tutorials to process[/green]")
        
        # Process tutorials
        async with aiohttp.ClientSession() as session:
            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                BarColumn(),
                TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
                console=console
            ) as progress:
                task = progress.add_task("Processing tutorials...", total=len(all_tutorials))
                
                for tutorial in all_tutorials:
                    await self.process_tutorial(session, tutorial)
                    progress.advance(task)
        
        # Create index file
        await self.create_index(all_tutorials)
        
        console.print(f"\n[bold green]âœ… Vault created at {self.vault_dir}[/bold green]")
    
    async def create_guide_index(self, urls_data: dict):
        """Create index pages for each guide."""
        for guide in urls_data.get('guides', []):
            guide_name = guide.get('title', 'Unknown Guide')
            guide_slug = slugify(guide_name)
            guide_file = self.guides_dir / f"{guide_slug}.md"
            
            content = [
                "---",
                f"title: \"{guide_name}\"",
                f"url: \"{guide.get('url', '')}\"",
                "type: guide",
                "---",
                "",
                f"# {guide_name}",
                "",
                "## Tutorials",
                ""
            ]
            
            for tutorial in guide.get('tutorials', []):
                tutorial_name = tutorial.get('title', 'Unknown Tutorial')
                content.append(f"- [[{tutorial_name}]]")
            
            async with aiofiles.open(guide_file, 'w', encoding='utf-8') as f:
                await f.write('\n'.join(content))
    
    async def process_tutorial(self, session: aiohttp.ClientSession, tutorial: dict):
        """Process a single tutorial into markdown."""
        title = tutorial.get('title', 'Untitled')
        tutorial_slug = slugify(title)
        tutorial_file = self.tutorials_dir / f"{tutorial_slug}.md"
        
        # Skip if already processed
        if tutorial_file.exists():
            return
        
        # Convert HTML to markdown
        html = tutorial.get('extractedHtml', '')
        body_markdown = html_to_markdown(html)
        
        # If no HTML, use body text
        if not body_markdown and tutorial.get('bodyText'):
            body_markdown = tutorial['bodyText']
        
        # Download images and update references
        for i, img_url in enumerate(tutorial.get('images', [])):
            try:
                parsed = urlparse(img_url)
                ext = Path(parsed.path).suffix or '.png'
                img_filename = f"{tutorial_slug}-{i}{ext}"
                img_dest = self.images_dir / img_filename
                
                if not img_dest.exists():
                    await download_file(session, img_url, img_dest)
                
                # Update markdown to use local path
                rel_path = f"../assets/images/{img_filename}"
                body_markdown = body_markdown.replace(img_url, rel_path)
            except Exception as e:
                console.print(f"[yellow]Could not process image {img_url}: {e}[/yellow]")
        
        # Handle videos
        video_links = []
        for video_url in tutorial.get('videos', []):
            if 'vimeo' in video_url:
                video_links.append(f"- [Vimeo Video]({video_url})")
            elif 'youtube' in video_url:
                video_links.append(f"- [YouTube Video]({video_url})")
            else:
                video_links.append(f"- [Video]({video_url})")
        
        # Build the markdown file
        content_parts = [
            create_frontmatter(tutorial),
            "",
            f"# {title}",
            ""
        ]
        
        if video_links:
            content_parts.extend([
                "## Videos",
                "",
                *video_links,
                ""
            ])
        
        content_parts.extend([
            "## Content",
            "",
            body_markdown
        ])
        
        # Write the file
        async with aiofiles.open(tutorial_file, 'w', encoding='utf-8') as f:
            await f.write('\n'.join(content_parts))
    
    async def create_index(self, tutorials: list):
        """Create main index file."""
        index_file = self.vault_dir / "README.md"
        
        # Group tutorials by guide
        guides = {}
        for t in tutorials:
            guide = t.get('guide', 'Uncategorized')
            if guide not in guides:
                guides[guide] = []
            guides[guide].append(t)
        
        content = [
            "# Drupalize.me Archive",
            "",
            f"*Extracted: {tutorials[0].get('extractedAt', 'Unknown') if tutorials else 'Unknown'}*",
            "",
            "## Guides",
            ""
        ]
        
        for guide_name, guide_tutorials in sorted(guides.items()):
            guide_slug = slugify(guide_name)
            content.append(f"### [[Guides/{guide_slug}|{guide_name}]]")
            content.append("")
            for t in guide_tutorials[:5]:  # Show first 5
                content.append(f"- [[Tutorials/{slugify(t.get('title', 'Untitled'))}|{t.get('title', 'Untitled')}]]")
            if len(guide_tutorials) > 5:
                content.append(f"- ... and {len(guide_tutorials) - 5} more")
            content.append("")
        
        async with aiofiles.open(index_file, 'w', encoding='utf-8') as f:
            await f.write('\n'.join(content))


@click.command()
@click.option(
    '--content-dir',
    type=click.Path(exists=True, file_okay=False, dir_okay=True, path_type=Path),
    default=Path('.'),
    help='Directory containing extracted JSON files (default: current directory)'
)
@click.option(
    '--vault-dir',
    type=click.Path(file_okay=False, dir_okay=True, path_type=Path),
    default=Path('./vault'),
    help='Directory for the Obsidian vault (default: ./vault)'
)
def main(content_dir: Path, vault_dir: Path):
    """
    Process extracted Drupalize.me content into an Obsidian vault.
    
    First run extract_urls.js and extract_content.js in your browser,
    then use this script to build the vault.
    """
    console.print("[bold cyan]Drupalize.me Vault Builder[/bold cyan]")
    console.print(f"Content directory: {content_dir.absolute()}")
    console.print(f"Vault directory: {vault_dir.absolute()}")
    console.print("")
    
    builder = VaultBuilder(vault_dir, content_dir)
    asyncio.run(builder.process_all())


if __name__ == '__main__':
    main()
